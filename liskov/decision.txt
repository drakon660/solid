AP vs AR â€” what they actually mean
AR â€” Accounts Receivable

Money that others owe you

You issue invoices to customers.

Typical characteristics:

You create the invoice

You send it to a customer

You wait for payment

PO is optional and usually just a reference

Simpler lifecycle

Examples:

Sales invoice

Customer invoice

Subscription invoice

ğŸ‘‰ Invoice is the core aggregate

AP â€” Accounts Payable

Money that you owe others

You receive invoices from vendors.

Typical characteristics:

Vendor sends invoice to you

Often must reference a Purchase Order

Requires approval workflows

Matching (2-way / 3-way)

Compliance & audit rules

Payment scheduling

Examples:

Vendor invoice

Supplier invoice

PO invoice

ğŸ‘‰ Much more complex domain

Why this matters in DDD
In AR

PO is usually just metadata

InvoiceWithPO is not a different concept

Same aggregate, same repository

Invoice
 â””â”€â”€ optional PurchaseOrderReference


Single collection

In AP

The business usually says things like:

â€œThis invoice must have a POâ€

â€œThis invoice cannot be paid until matchedâ€

â€œThis invoice is blocked pending approvalâ€

Here:

PO is not just data

It drives behavior

It affects lifecycle

Now you often get:

NonPoInvoice

PoInvoice

or VendorInvoice with explicit subtypes

ğŸ‘‰ These are different aggregates or aggregate variants with hard invariants

Separate collections become reasonable

Typical DDD modeling outcome
AR context
Bounded Context: Billing / Sales

Aggregate: Invoice
- may reference PurchaseOrderId
- same lifecycle

â†’ ONE collection

AP context
Bounded Context: AccountsPayable

Aggregates:
- PoInvoice
- NonPoInvoice

Different rules, different flows

â†’ SEPARATE collections (often)

Important DDD insight (many teams miss this)

AP and AR should almost always be separate bounded contexts

Even if:

both use the word â€œInvoiceâ€

both store similar fields

They mean different things.

Sharing a table/collection between AP and AR is usually a design smell.

Quick decision table
Question	If YES â†’
Is this AR (we invoice customers)?	Single Invoice
Is this AP (vendors invoice us)?	Likely split
PO changes lifecycle?	Separate aggregate
Approval / matching required?	Separate aggregate
Same language & rules?	Same collection
Bottom line

AR â†’ Invoice (+ optional PO) â†’ one collection

AP â†’ PO-driven behavior â†’ separate aggregates, often separate collections

AP â‰  AR, even if the schema looks similar

If you want, tell me which side youâ€™re modeling right now (AP or AR), and Iâ€™ll sketch a concrete aggregate + repository layout in DDD terms.